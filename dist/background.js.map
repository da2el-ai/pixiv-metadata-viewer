{"version":3,"file":"background.js","sources":["../src/background/index.ts"],"sourcesContent":["/**\n * バックグラウンドスクリプト\n * メタデータの取得と解析を担当\n */\nimport { CONFIG } from '../constants';\n\n/**\n * デバッグ情報をコンテンツスクリプトに送信\n */\nfunction sendDebugInfo(tabId: number | undefined, label: string, data?: any, error?: any): void {\n  if (!tabId) return;\n  \n  chrome.tabs.sendMessage(tabId, {\n    type: 'DEBUG_INFO',\n    label,\n    data,\n    error: error ? (error instanceof Error ? error.message : String(error)) : undefined\n  });\n}\n\n/**\n * PNGのαチャンネルに埋め込まれたメタデータを抽出\n * NovelAIなどで使用されるstealth_pngcompフォーマットに対応\n */\nasync function parsePngAlphaChannel(buf: ArrayBuffer, tabId?: number): Promise<any | null> {\n  try {\n    // 画像をデコード\n    const blob = new Blob([buf], { type: 'image/png' });\n    const imgBitmap = await createImageBitmap(blob);\n    \n    // // デバッグ情報を送信\n    // if (tabId) {\n    //   sendDebugInfo(tabId, 'αチャンネル解析開始', {\n    //     width: imgBitmap.width,\n    //     height: imgBitmap.height,\n    //     size: buf.byteLength\n    //   });\n    // }\n    \n    // OffscreenCanvasを作成して画像を描画\n    const canvas = new OffscreenCanvas(imgBitmap.width, imgBitmap.height);\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('2Dコンテキストの取得に失敗しました');\n    }\n    \n    ctx.drawImage(imgBitmap, 0, 0);\n    const imageData = ctx.getImageData(0, 0, imgBitmap.width, imgBitmap.height);\n    const pixels = imageData.data;\n    \n    // αチャンネルの最下位ビットを抽出\n    const alphaChannel = new Uint8Array(Math.floor(pixels.length / 4));\n    for (let i = 0; i < pixels.length; i += 4) {\n      alphaChannel[i / 4] = pixels[i + 3] & 1; // αチャンネルの最下位ビット\n    }\n    \n    // // デバッグ情報を送信\n    // if (tabId) {\n    //   sendDebugInfo(tabId, 'αチャンネル抽出完了', {\n    //     alphaChannelLength: alphaChannel.length,\n    //     sampleValues: Array.from(alphaChannel.slice(0, 20)) // 最初の20個の値をサンプルとして送信\n    //   });\n    // }\n    \n    // Pythonの実装に合わせて転置処理を追加\n    // 画像データは行優先で格納されているため、列優先に変換する\n    const width = imgBitmap.width;\n    const height = imgBitmap.height;\n    const transposedAlphaChannel = new Uint8Array(alphaChannel.length);\n    \n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        // 転置: (x, y) -> (y, x)\n        transposedAlphaChannel[x * height + y] = alphaChannel[y * width + x];\n      }\n    }\n    \n    // if (tabId) {\n    //   sendDebugInfo(tabId, 'αチャンネル転置完了', {\n    //     sampleValues: Array.from(transposedAlphaChannel.slice(0, 20)) // 最初の20個の値をサンプルとして送信\n    //   });\n    // }\n    \n    // 8ビットごとにバイトにパック\n    // Pythonの実装に合わせて、8の倍数に切り捨て\n    const packedLength = Math.floor(transposedAlphaChannel.length / 8) * 8;\n    const truncatedAlphaChannel = transposedAlphaChannel.slice(0, packedLength);\n    const packedBytes = new Uint8Array(Math.floor(packedLength / 8));\n    \n    for (let i = 0; i < packedBytes.length; i++) {\n      let byte = 0;\n      for (let j = 0; j < 8; j++) {\n        byte |= (truncatedAlphaChannel[i * 8 + j] << (7 - j));\n      }\n      packedBytes[i] = byte;\n    }\n    \n    // if (tabId) {\n    //   sendDebugInfo(tabId, 'バイトパック完了', {\n    //     packedLength: packedBytes.length,\n    //     sampleValues: Array.from(packedBytes.slice(0, 20)) // 最初の20個の値をサンプルとして送信\n    //   });\n    // }\n    \n    // LSBExtractorの実装\n    class LSBExtractor {\n      private data: Uint8Array;\n      private pos: number;\n      \n      constructor(data: Uint8Array) {\n        this.data = data;\n        this.pos = 0;\n      }\n      \n      getNextNBytes(n: number): Uint8Array {\n        const bytes = this.data.slice(this.pos, this.pos + n);\n        this.pos += n;\n        return bytes;\n      }\n      \n      read32BitInteger(): number | null {\n        const bytes = this.getNextNBytes(4);\n        if (bytes.length === 4) {\n          return (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3];\n        }\n        return null;\n      }\n    }\n    \n    // メタデータの抽出\n    const reader = new LSBExtractor(packedBytes);\n    \n    // マジックナンバーの確認\n    const magic = \"stealth_pngcomp\";\n    const magicBytes = reader.getNextNBytes(magic.length);\n    const readMagic = new TextDecoder().decode(magicBytes);\n    \n    // デバッグ情報を送信\n    // if (tabId) {\n    //   sendDebugInfo(tabId, 'マジックナンバー確認', {\n    //     expected: magic,\n    //     actual: readMagic,\n    //     match: magic === readMagic\n    //   });\n    // }\n    \n    if (magic !== readMagic) {\n      // マジックナンバーが一致しない場合はメタデータなし\n      // if (tabId) {\n      //   sendDebugInfo(tabId, 'マジックナンバー不一致', {\n      //     expected: magic,\n      //     actual: readMagic\n      //   });\n      // }\n      return null;\n    }\n    \n    // データ長の読み取り\n    const dataLength = reader.read32BitInteger();\n    if (dataLength === null) {\n      return null;\n    }\n    \n    // JSONデータの読み取り\n    const jsonDataBytes = reader.getNextNBytes(Math.floor(dataLength / 8));\n    \n    // gzip解凍\n    const decompressed = await decompressGzip(jsonDataBytes);\n    const jsonText = new TextDecoder().decode(decompressed);\n    const jsonData = JSON.parse(jsonText);\n    \n    // Commentフィールドが文字列の場合はJSONとして解析\n    if (jsonData.Comment && typeof jsonData.Comment === 'string') {\n      try {\n        jsonData.Comment = JSON.parse(jsonData.Comment);\n      } catch (e) {\n        // 解析に失敗した場合は文字列のまま\n      }\n    }\n    \n    // メタデータをitemsフォーマットに変換して返す\n    const items = Object.entries(jsonData).map(([key, value]) => {\n      return {\n        type: 'tEXt',\n        keyword: key,\n        text: JSON.stringify(value),\n      }\n    });\n\n    return {items: items};\n\n  } catch (e) {\n    // if (tabId) {\n    //   sendDebugInfo(tabId, 'αチャンネルメタデータ抽出エラー', null, e);\n    // }\n    return null;\n  }\n}\n\n/**\n * gzip圧縮データを解凍\n */\nasync function decompressGzip(data: Uint8Array): Promise<ArrayBuffer> {\n  const blob = new Blob([data as unknown as BlobPart]);\n  const stream = new Response(\n    blob.stream().pipeThrough(new DecompressionStream('gzip'))\n  );\n  return await stream.arrayBuffer();\n}\n\n/**\n * PNG画像のテキストチャンクを解析\n */\nasync function parsePngTextChunks(buf: ArrayBuffer): Promise<any> {\n  const u8 = new Uint8Array(buf);\n  const dv = new DataView(buf);\n  \n  // PNG署名チェック\n  const sig = [137, 80, 78, 71, 13, 10, 26, 10];\n  for (let i = 0; i < 8; i++) {\n    if (u8[i] !== sig[i]) {\n      throw new Error('PNG署名が一致しません');\n    }\n  }\n  \n  let off = 8;\n  const latin1 = new TextDecoder('latin1');\n  const utf8 = new TextDecoder();\n  const items = [];\n  \n  while (off + 8 <= dv.byteLength) {\n    const len = dv.getUint32(off);\n    off += 4;\n    \n    if (off + 4 > dv.byteLength) break;\n    \n    const type = String.fromCharCode(u8[off], u8[off+1], u8[off+2], u8[off+3]);\n    off += 4;\n    \n    if (off + len + 4 > dv.byteLength) break; // 範囲外\n    \n    const data = u8.slice(off, off + len);\n    off += len;\n    \n    const _crc = dv.getUint32(off);\n    off += 4;\n\n    try {\n      if (type === 'tEXt') {\n        // 非圧縮テキスト\n        const sep = data.indexOf(0);\n        const keyword = latin1.decode(data.slice(0, sep));\n        const text = latin1.decode(data.slice(sep + 1));\n        items.push({ type, keyword, text });\n      } else if (type === 'iTXt') {\n        // 国際テキスト\n        let p = 0;\n        const i0 = data.indexOf(0, p);\n        const keyword = latin1.decode(data.slice(p, i0));\n        p = i0 + 1;\n        \n        const compFlag = data[p++];\n        const compMethod = data[p++];\n        \n        const i1 = data.indexOf(0, p);\n        const languageTag = latin1.decode(data.slice(p, i1));\n        p = i1 + 1;\n        \n        const i2 = data.indexOf(0, p);\n        const translatedKeyword = utf8.decode(data.slice(p, i2));\n        p = i2 + 1;\n        \n        const textBytes = data.slice(p);\n        let text;\n        \n        if (compFlag === 1) {\n          text = await inflateToString(textBytes); // zlib圧縮\n        } else {\n          text = utf8.decode(textBytes);\n        }\n        \n        items.push({\n          type,\n          keyword,\n          text,\n          languageTag,\n          translatedKeyword,\n          compMethod\n        });\n      } else if (type === 'zTXt') {\n        // 圧縮テキスト\n        const sep = data.indexOf(0);\n        const keyword = latin1.decode(data.slice(0, sep));\n        const compMethod = data[sep + 1];\n        const compressed = data.slice(sep + 2);\n        const text = await inflateToString(compressed);\n        items.push({ type, keyword, text, compMethod });\n      }\n    } catch (e) {\n      items.push({ type, keyword: 'parse-error', text: String(e) });\n    }\n\n    if (type === 'IEND') break;\n  }\n  \n  return { items };\n}\n\n/**\n * 圧縮データを展開してテキストに変換\n */\nasync function inflateToString(u8: Uint8Array): Promise<string> {\n  if (typeof DecompressionStream === 'function') {\n    try {\n      const blob = new Blob([u8 as unknown as BlobPart]);\n      const stream = new Response(\n        blob.stream().pipeThrough(new DecompressionStream('deflate'))\n      );\n      const ab = await stream.arrayBuffer();\n      return new TextDecoder().decode(ab);\n    } catch (e) {\n      // deflate-rawを試す\n      try { \n        const blob = new Blob([u8 as unknown as BlobPart]);\n        const stream = new Response(\n          blob.stream().pipeThrough(new DecompressionStream('deflate-raw'))\n        );\n        const ab = await stream.arrayBuffer();\n        return new TextDecoder().decode(ab);\n      } catch (e) {\n        // どちらも失敗\n      }\n    }\n  }\n  \n  throw new Error('DecompressionStream未対応のため圧縮テキストを展開できません');\n}\n\n\n/**\n * 画像からメタデータを取得\n */\nasync function fetchAndParseMetadata(url: string, tabId?: number): Promise<any> {\n  // // デバッグ情報を送信\n  // if (tabId) {\n  //   sendDebugInfo(tabId, '画像取得開始', { url });\n  // }\n  \n  // 画像を取得\n  const res = await fetch(url, {\n    // DNRでRefererは強制付与される想定\n    credentials: 'omit',\n    cache: 'no-cache',\n    mode: 'cors'\n  });\n  \n  if (!res.ok) {\n    // if (tabId) {\n    //   sendDebugInfo(tabId, '画像取得失敗', { url, status: res.status });\n    // }\n    throw new Error(`画像取得に失敗: HTTP ${res.status}`);\n  }\n  \n  const buf = await res.arrayBuffer();\n  \n  // if (tabId) {\n  //   sendDebugInfo(tabId, '画像取得完了', { \n  //     url, \n  //     size: buf.byteLength,\n  //     contentType: res.headers.get('content-type')\n  //   });\n  // }\n  \n  try {\n    // 拡張子に基づいて解析\n    let parsed;\n    const urlLower = url.toLowerCase();\n    \n    if (urlLower.endsWith('.png')) {\n      // if (tabId) {\n      //   sendDebugInfo(tabId, 'PNG画像の解析開始', { url });\n      // }\n      \n      // まずαチャンネルからメタデータを抽出を試みる\n      parsed = await parsePngAlphaChannel(buf, tabId);\n      \n      if (parsed) {\n        // if (tabId) {\n        //   sendDebugInfo(tabId, 'αチャンネルからメタデータ抽出成功', { \n        //     itemsCount: parsed.items?.length || 0\n        //   });\n        // }\n      } else {\n        // if (tabId) {\n        //   sendDebugInfo(tabId, 'αチャンネルからメタデータ抽出失敗、テキストチャンク解析に移行');\n        // }\n        // αチャンネルからメタデータが見つからなければテキストチャンクを解析\n        parsed = await parsePngTextChunks(buf);\n        \n        // if (tabId) {\n        //   sendDebugInfo(tabId, 'テキストチャンク解析結果', { \n        //     success: !!parsed,\n        //     itemsCount: parsed?.items?.length || 0\n        //   });\n        // }\n      }\n    } else {\n      // PNG以外の形式の場合は何もせず処理を完了\n      return { \n        ok: true, \n        isNotPng: true,\n        parsed: { items: [] }, \n        bytes: buf.byteLength \n      };\n    }\n    \n    // summary の生成部分を削除\n    return { ok: true, parsed, bytes: buf.byteLength };\n  } catch (e) {\n    // if (tabId) {\n    //   sendDebugInfo(tabId, 'メタデータ解析エラー', null, e);\n    // }\n    // エラーが発生しても空の結果を返す\n    return { ok: true, parsed: { items: [] }, bytes: buf.byteLength };\n  }\n}\n\n/**\n * 拡張機能アイコンのクリックイベント\n */\nchrome.action.onClicked.addListener((tab) => {\n  if (tab.id) {\n    chrome.tabs.sendMessage(tab.id, { type: 'TOGGLE_PANEL' });\n  }\n});\n\n/**\n * メッセージハンドラ\n */\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message && message.type === 'GET_METADATA') {\n    (async () => {\n      try {\n        const { imageUrls } = message;\n        const tabId = sender.tab?.id;\n        \n        if (!imageUrls || !Array.isArray(imageUrls) || imageUrls.length === 0) {\n          if (tabId) {\n            sendDebugInfo(tabId, 'メタデータ取得エラー', null, '有効な画像URLが指定されていません');\n          }\n          sendResponse({ success: false, log: '有効な画像URLが指定されていません' });\n          return;\n        }\n        \n        // if (tabId) {\n        //   sendDebugInfo(tabId, 'メタデータ取得開始', { imageUrls });\n        // }\n        \n        // 画像URLを順番に試行\n        for (const url of imageUrls) {\n          try {\n            const metadata = await fetchAndParseMetadata(url, tabId);\n            sendResponse({ success: true, metadata, url });\n            return;\n          } catch (err: any) {\n            // 404の場合は次のURLを試す、それ以外はエラー\n            if (err.message.includes('HTTP 404')) {\n              continue;\n            }\n            // PNG以外の形式はまだサポートされていない場合も次のURLを試す\n            if (err.message.includes('PNG以外の形式はまだサポートされていません')) {\n              continue;\n            }\n            throw err;\n          }\n        }\n        \n        // すべてのURLで失敗\n        sendResponse({ success: false, log: 'メタデータが見つかりません' });\n      } catch (e: any) {\n        sendResponse({ success: false, log: e.message || String(e) });\n      }\n    })();\n    return true; // 非同期レスポンス\n  }\n});\n"],"names":["sendDebugInfo","tabId","label","data","error","parsePngAlphaChannel","buf","blob","imgBitmap","ctx","pixels","alphaChannel","width","height","transposedAlphaChannel","y","x","packedLength","truncatedAlphaChannel","packedBytes","byte","j","LSBExtractor","__publicField","n","bytes","reader","magic","magicBytes","readMagic","dataLength","jsonDataBytes","decompressed","decompressGzip","jsonText","jsonData","key","value","parsePngTextChunks","u8","dv","sig","i","off","latin1","utf8","items","len","type","sep","keyword","text","p","i0","compFlag","compMethod","i1","languageTag","i2","translatedKeyword","textBytes","inflateToString","compressed","e","ab","fetchAndParseMetadata","url","res","parsed","tab","message","sender","sendResponse","_a","imageUrls","metadata","err"],"mappings":"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"}