{"version":3,"file":"background.js","sources":["../src/background/parseMetadata.ts","../src/background/util.ts","../src/background/index.ts"],"sourcesContent":["/**\n * メタデータの解析を担当するモジュール\n */\nimport { sendDebugInfo } from './util';\n\n/**\n * LSBExtractorクラス - バイナリデータからビットを抽出するためのユーティリティ\n */\nexport class LSBExtractor {\n  private data: Uint8Array;\n  private pos: number;\n  \n  constructor(data: Uint8Array) {\n    this.data = data;\n    this.pos = 0;\n  }\n  \n  getNextNBytes(n: number): Uint8Array {\n    const bytes = this.data.slice(this.pos, this.pos + n);\n    this.pos += n;\n    return bytes;\n  }\n  \n  read32BitInteger(): number | null {\n    const bytes = this.getNextNBytes(4);\n    if (bytes.length === 4) {\n      return (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3];\n    }\n    return null;\n  }\n}\n\n/**\n * 画像データからアルファチャンネルの最下位ビットを抽出\n */\nexport function extractAlphaChannelBits(pixels: Uint8ClampedArray | Uint8Array, width: number, height: number): Uint8Array {\n  // αチャンネルの最下位ビットを抽出\n  const alphaChannel = new Uint8Array(Math.floor(pixels.length / 4));\n  for (let i = 0; i < pixels.length; i += 4) {\n    alphaChannel[i / 4] = pixels[i + 3] & 1; // αチャンネルの最下位ビット\n  }\n  \n  // 転置処理（行優先から列優先へ）\n  const transposedAlphaChannel = new Uint8Array(alphaChannel.length);\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      // 転置: (x, y) -> (y, x)\n      transposedAlphaChannel[x * height + y] = alphaChannel[y * width + x];\n    }\n  }\n  \n  return transposedAlphaChannel;\n}\n\n/**\n * 画像データからRGBチャンネルの最下位ビットを抽出\n */\nexport function extractRGBChannelBits(pixels: Uint8ClampedArray | Uint8Array, width: number, height: number, columnMajor: boolean = false): Uint8Array {\n  const rgbBits = new Uint8Array(width * height * 3);\n  let index = 0;\n  \n  if (columnMajor) {\n    // 列優先（x, y）\n    for (let x = 0; x < width; x++) {\n      for (let y = 0; y < height; y++) {\n        const pixelIndex = (y * width + x) * 4;\n        rgbBits[index++] = pixels[pixelIndex] & 1;     // R\n        rgbBits[index++] = pixels[pixelIndex + 1] & 1; // G\n        rgbBits[index++] = pixels[pixelIndex + 2] & 1; // B\n      }\n    }\n  } else {\n    // 行優先（y, x）\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const pixelIndex = (y * width + x) * 4;\n        rgbBits[index++] = pixels[pixelIndex] & 1;     // R\n        rgbBits[index++] = pixels[pixelIndex + 1] & 1; // G\n        rgbBits[index++] = pixels[pixelIndex + 2] & 1; // B\n      }\n    }\n  }\n  \n  return rgbBits;\n}\n\n/**\n * ビット配列を8ビットごとにバイトにパック\n */\nexport function packBitsToBytes(bits: Uint8Array): Uint8Array {\n  // 8の倍数に切り捨て\n  const packedLength = Math.floor(bits.length / 8) * 8;\n  const truncatedBits = bits.slice(0, packedLength);\n  const packedBytes = new Uint8Array(Math.floor(packedLength / 8));\n  \n  for (let i = 0; i < packedBytes.length; i++) {\n    let byte = 0;\n    for (let j = 0; j < 8; j++) {\n      byte |= (truncatedBits[i * 8 + j] << (7 - j));\n    }\n    packedBytes[i] = byte;\n  }\n  \n  return packedBytes;\n}\n\n/**\n * マジックナンバーを確認し、メタデータ形式を判定\n */\nexport function checkMagicNumber(reader: LSBExtractor): { \n  isValid: boolean; \n  format: string | null; \n  isCompressed: boolean | null; \n} {\n  // 可能なマジックナンバー\n  const magicNumbers = [\n    { magic: \"stealth_pngcomp\", format: \"alpha\", compressed: true },\n    { magic: \"stealth_pnginfo\", format: \"alpha\", compressed: false },\n    { magic: \"stealth_rgbcomp\", format: \"rgb\", compressed: true },\n    { magic: \"stealth_rgbinfo\", format: \"rgb\", compressed: false }\n  ];\n  \n  // 最長のマジックナンバーの長さを取得\n  const maxLength = Math.max(...magicNumbers.map(m => m.magic.length));\n  \n  // マジックナンバーの長さ分のバイトを読み取る\n  const magicBytes = reader.getNextNBytes(maxLength);\n  const readMagic = new TextDecoder().decode(magicBytes);\n  \n  // マジックナンバーを確認\n  for (const { magic, format, compressed } of magicNumbers) {\n    if (readMagic.startsWith(magic)) {\n      return { isValid: true, format, isCompressed: compressed };\n    }\n  }\n  \n  return { isValid: false, format: null, isCompressed: null };\n}\n\n/**\n * gzip圧縮データを解凍\n */\nexport async function decompressGzip(data: Uint8Array): Promise<ArrayBuffer> {\n  const blob = new Blob([data as unknown as BlobPart]);\n  const stream = new Response(\n    blob.stream().pipeThrough(new DecompressionStream('gzip'))\n  );\n  return await stream.arrayBuffer();\n}\n\n/**\n * 圧縮データを展開してテキストに変換\n */\nexport async function inflateToString(u8: Uint8Array): Promise<string> {\n  if (typeof DecompressionStream === 'function') {\n    try {\n      const blob = new Blob([u8 as unknown as BlobPart]);\n      const stream = new Response(\n        blob.stream().pipeThrough(new DecompressionStream('deflate'))\n      );\n      const ab = await stream.arrayBuffer();\n      return new TextDecoder().decode(ab);\n    } catch (e) {\n      // deflate-rawを試す\n      try { \n        const blob = new Blob([u8 as unknown as BlobPart]);\n        const stream = new Response(\n          blob.stream().pipeThrough(new DecompressionStream('deflate-raw'))\n        );\n        const ab = await stream.arrayBuffer();\n        return new TextDecoder().decode(ab);\n      } catch (e) {\n        // どちらも失敗\n      }\n    }\n  }\n  \n  throw new Error('DecompressionStream未対応のため圧縮テキストを展開できません');\n}\n\n/**\n * PNGのαチャンネルに埋め込まれたメタデータを抽出\n * NovelAIなどで使用されるstealth_pngcompフォーマットに対応\n */\nexport async function parsePngAlphaChannel(buf: ArrayBuffer): Promise<any | null> {\n  try {\n    // 画像をデコード\n    const blob = new Blob([buf], { type: 'image/png' });\n    const imgBitmap = await createImageBitmap(blob);\n    \n    // OffscreenCanvasを作成して画像を描画\n    const canvas = new OffscreenCanvas(imgBitmap.width, imgBitmap.height);\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('2Dコンテキストの取得に失敗しました');\n    }\n    \n    ctx.drawImage(imgBitmap, 0, 0);\n    const imageData = ctx.getImageData(0, 0, imgBitmap.width, imgBitmap.height);\n    const pixels = imageData.data;\n    \n    // αチャンネルの最下位ビットを抽出して転置\n    const transposedAlphaChannel = extractAlphaChannelBits(pixels, imgBitmap.width, imgBitmap.height);\n    \n    // 8ビットごとにバイトにパック\n    const packedBytes = packBitsToBytes(transposedAlphaChannel);\n    \n    // メタデータの抽出\n    const reader = new LSBExtractor(packedBytes);\n    \n    // マジックナンバーの確認\n    const magic = \"stealth_pngcomp\";\n    const magicBytes = reader.getNextNBytes(magic.length);\n    const readMagic = new TextDecoder().decode(magicBytes);\n    \n    if (magic !== readMagic) {\n      // マジックナンバーが一致しない場合はメタデータなし\n      return null;\n    }\n    \n    // データ長の読み取り\n    const dataLength = reader.read32BitInteger();\n    if (dataLength === null) {\n      return null;\n    }\n    \n    // JSONデータの読み取り\n    const jsonDataBytes = reader.getNextNBytes(Math.floor(dataLength / 8));\n    \n    // gzip解凍\n    const decompressed = await decompressGzip(jsonDataBytes);\n    const jsonText = new TextDecoder().decode(decompressed);\n    const jsonData = JSON.parse(jsonText);\n    \n    // Commentフィールドが文字列の場合はJSONとして解析\n    if (jsonData.Comment && typeof jsonData.Comment === 'string') {\n      try {\n        jsonData.Comment = JSON.parse(jsonData.Comment);\n      } catch (e) {\n        // 解析に失敗した場合は文字列のまま\n      }\n    }\n    \n    // メタデータをitemsフォーマットに変換して返す\n    const items = Object.entries(jsonData).map(([key, value]) => {\n      return {\n        type: 'tEXt',\n        keyword: key,\n        text: JSON.stringify(value),\n      }\n    });\n\n    return {items: items};\n\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * StableDiffusion Forgeのメタデータを抽出\n * アルファチャンネルモードとRGBモードの両方に対応\n */\nexport async function parseStableDiffusionForgeMetadata(buf: ArrayBuffer, tabId?: number): Promise<any | null> {\n  try {\n    // 画像をデコード\n    const blob = new Blob([buf], { type: 'image/png' });\n    const imgBitmap = await createImageBitmap(blob);\n    \n    // OffscreenCanvasを作成して画像を描画\n    const canvas = new OffscreenCanvas(imgBitmap.width, imgBitmap.height);\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('2Dコンテキストの取得に失敗しました');\n    }\n    \n    ctx.drawImage(imgBitmap, 0, 0);\n    const imageData = ctx.getImageData(0, 0, imgBitmap.width, imgBitmap.height);\n    const pixels = imageData.data;\n    const width = imgBitmap.width;\n    const height = imgBitmap.height;\n    \n    // メタデータを抽出\n    let metadataText: string | null = null;\n    \n    // アルファチャンネルからメタデータを抽出\n    const alphaBits = extractAlphaChannelBits(pixels, width, height);\n    const alphaBytes = packBitsToBytes(alphaBits);\n    const alphaReader = new LSBExtractor(alphaBytes);\n    const alphaResult = checkMagicNumber(alphaReader);\n    \n    if (alphaResult.isValid) {\n      // データ長の読み取り\n      const dataLength = alphaReader.read32BitInteger();\n      if (dataLength !== null) {\n        // データの読み取り\n        const dataBytes = alphaReader.getNextNBytes(Math.floor(dataLength / 8));\n        \n        // 圧縮されている場合は解凍\n        if (alphaResult.isCompressed) {\n          const decompressed = await decompressGzip(dataBytes);\n          metadataText = new TextDecoder().decode(decompressed);\n        } else {\n          metadataText = new TextDecoder().decode(dataBytes);\n        }\n      }\n    }\n    \n    // アルファチャンネルでメタデータが見つからなかった場合、RGBチャンネルを試す\n    if (metadataText === null) {\n      // 行優先でRGBチャンネルからメタデータを抽出\n      const rgbBits = extractRGBChannelBits(pixels, width, height);\n      const rgbBytes = packBitsToBytes(rgbBits);\n      const rgbReader = new LSBExtractor(rgbBytes);\n      const rgbResult = checkMagicNumber(rgbReader);\n      \n      if (rgbResult.isValid) {\n        // データ長の読み取り\n        const dataLength = rgbReader.read32BitInteger();\n        if (dataLength !== null) {\n          // データの読み取り\n          const dataBytes = rgbReader.getNextNBytes(Math.floor(dataLength / 8));\n          \n          // 圧縮されている場合は解凍\n          if (rgbResult.isCompressed) {\n            const decompressed = await decompressGzip(dataBytes);\n            metadataText = new TextDecoder().decode(decompressed);\n          } else {\n            metadataText = new TextDecoder().decode(dataBytes);\n          }\n        }\n      } else {\n        // 列優先でRGBチャンネルからメタデータを抽出\n        const rgbBits2 = extractRGBChannelBits(pixels, width, height, true);\n        const rgbBytes2 = packBitsToBytes(rgbBits2);\n        const rgbReader2 = new LSBExtractor(rgbBytes2);\n        const rgbResult2 = checkMagicNumber(rgbReader2);\n        \n        if (rgbResult2.isValid) {\n          // データ長の読み取り\n          const dataLength = rgbReader2.read32BitInteger();\n          if (dataLength !== null) {\n            // データの読み取り\n            const dataBytes = rgbReader2.getNextNBytes(Math.floor(dataLength / 8));\n            \n            // 圧縮されている場合は解凍\n            if (rgbResult2.isCompressed) {\n              const decompressed = await decompressGzip(dataBytes);\n              metadataText = new TextDecoder().decode(decompressed);\n            } else {\n              metadataText = new TextDecoder().decode(dataBytes);\n            }\n          }\n        }\n      }\n    }\n    \n    // メタデータが見つからなかった場合\n    if (metadataText === null) {\n      return null;\n    }\n    \n    // メタデータをitemsフォーマットに変換して返す\n    return {\n      items: [\n        {\n          type: 'tEXt',\n          keyword: 'parameters',\n          text: metadataText\n        }\n      ]\n    };\n    \n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * PNG画像のテキストチャンクを解析\n */\nexport async function parsePngTextChunks(buf: ArrayBuffer): Promise<any> {\n  const u8 = new Uint8Array(buf);\n  const dv = new DataView(buf);\n  \n  // PNG署名チェック\n  const sig = [137, 80, 78, 71, 13, 10, 26, 10];\n  for (let i = 0; i < 8; i++) {\n    if (u8[i] !== sig[i]) {\n      throw new Error('PNG署名が一致しません');\n    }\n  }\n  \n  let off = 8;\n  const latin1 = new TextDecoder('latin1');\n  const utf8 = new TextDecoder();\n  const items = [];\n  \n  while (off + 8 <= dv.byteLength) {\n    const len = dv.getUint32(off);\n    off += 4;\n    \n    if (off + 4 > dv.byteLength) break;\n    \n    const type = String.fromCharCode(u8[off], u8[off+1], u8[off+2], u8[off+3]);\n    off += 4;\n    \n    if (off + len + 4 > dv.byteLength) break; // 範囲外\n    \n    const data = u8.slice(off, off + len);\n    off += len;\n    \n    const _crc = dv.getUint32(off);\n    off += 4;\n\n    try {\n      if (type === 'tEXt') {\n        // 非圧縮テキスト\n        const sep = data.indexOf(0);\n        const keyword = latin1.decode(data.slice(0, sep));\n        const text = latin1.decode(data.slice(sep + 1));\n        items.push({ type, keyword, text });\n      } else if (type === 'iTXt') {\n        // 国際テキスト\n        let p = 0;\n        const i0 = data.indexOf(0, p);\n        const keyword = latin1.decode(data.slice(p, i0));\n        p = i0 + 1;\n        \n        const compFlag = data[p++];\n        const compMethod = data[p++];\n        \n        const i1 = data.indexOf(0, p);\n        const languageTag = latin1.decode(data.slice(p, i1));\n        p = i1 + 1;\n        \n        const i2 = data.indexOf(0, p);\n        const translatedKeyword = utf8.decode(data.slice(p, i2));\n        p = i2 + 1;\n        \n        const textBytes = data.slice(p);\n        let text;\n        \n        if (compFlag === 1) {\n          text = await inflateToString(textBytes); // zlib圧縮\n        } else {\n          text = utf8.decode(textBytes);\n        }\n        \n        items.push({\n          type,\n          keyword,\n          text,\n          languageTag,\n          translatedKeyword,\n          compMethod\n        });\n      } else if (type === 'zTXt') {\n        // 圧縮テキスト\n        const sep = data.indexOf(0);\n        const keyword = latin1.decode(data.slice(0, sep));\n        const compMethod = data[sep + 1];\n        const compressed = data.slice(sep + 2);\n        const text = await inflateToString(compressed);\n        items.push({ type, keyword, text, compMethod });\n      }\n    } catch (e) {\n      items.push({ type, keyword: 'parse-error', text: String(e) });\n    }\n\n    if (type === 'IEND') break;\n  }\n  \n  return { items };\n}\n\n/**\n * 画像からメタデータを取得\n */\nexport async function fetchAndParseMetadata(url: string, tabId?: number): Promise<any> {\n  // 画像を取得\n  const res = await fetch(url, {\n    // DNRでRefererは強制付与される想定\n    credentials: 'omit',\n    cache: 'no-cache',\n    mode: 'cors'\n  });\n  \n  if (!res.ok) {\n    throw new Error(`画像取得に失敗: HTTP ${res.status}`);\n  }\n  \n  const buf = await res.arrayBuffer();\n  \n  try {\n    // 拡張子に基づいて解析\n    let parsed;\n    const urlLower = url.toLowerCase();\n    \n    if (urlLower.endsWith('.png')) {\n      // まずStableDiffusion Forgeのメタデータを抽出を試みる\n      parsed = await parseStableDiffusionForgeMetadata(buf, tabId);\n      \n      // StableDiffusion Forgeのメタデータが見つからなければNovelAIのメタデータを抽出\n      if (!parsed) {\n        parsed = await parsePngAlphaChannel(buf);\n      }\n      \n      // どちらも見つからなければテキストチャンクを解析\n      if (!parsed) {\n        parsed = await parsePngTextChunks(buf);\n      }\n    } else {\n      // PNG以外の形式の場合は何もせず処理を完了\n      return { \n        ok: true, \n        isNotPng: true,\n        parsed: { items: [] }, \n        bytes: buf.byteLength \n      };\n    }\n    \n    return { ok: true, parsed, bytes: buf.byteLength };\n  } catch (e) {\n    // エラーが発生しても空の結果を返す\n    return { ok: true, parsed: { items: [] }, bytes: buf.byteLength };\n  }\n}\n","/**\n * バックグラウンドスクリプトのユーティリティ関数\n */\n\n/**\n * デバッグ情報をコンテンツスクリプトに送信\n */\nexport function sendDebugInfo(tabId: number | undefined, label: string, data?: any, error?: any): void {\n  if (!tabId) return;\n  \n  chrome.tabs.sendMessage(tabId, {\n    type: 'DEBUG_INFO',\n    label,\n    data,\n    error: error ? (error instanceof Error ? error.message : String(error)) : undefined\n  });\n}\n","/**\n * バックグラウンドスクリプト\n * メタデータの取得と解析を担当\n */\nimport { CONFIG } from '../constants';\nimport { fetchAndParseMetadata } from './parseMetadata';\nimport { sendDebugInfo } from './util';\n\n/**\n * 拡張機能アイコンのクリックイベント\n */\nchrome.action.onClicked.addListener((tab) => {\n  if (tab.id) {\n    chrome.tabs.sendMessage(tab.id, { type: 'TOGGLE_PANEL' });\n  }\n});\n\n/**\n * メッセージハンドラ\n */\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message && message.type === 'GET_METADATA') {\n    (async () => {\n      try {\n        const { imageUrls } = message;\n        const tabId = sender.tab?.id;\n        \n        if (!imageUrls || !Array.isArray(imageUrls) || imageUrls.length === 0) {\n          if (tabId) {\n            sendDebugInfo(tabId, 'メタデータ取得エラー', null, '有効な画像URLが指定されていません');\n          }\n          sendResponse({ success: false, log: '有効な画像URLが指定されていません' });\n          return;\n        }\n        \n        // 画像URLを順番に試行\n        for (const url of imageUrls) {\n          try {\n            const metadata = await fetchAndParseMetadata(url, tabId);\n            sendResponse({ success: true, metadata, url });\n            return;\n          } catch (err: any) {\n            // 404の場合は次のURLを試す、それ以外はエラー\n            if (err.message.includes('HTTP 404')) {\n              continue;\n            }\n            // PNG以外の形式はまだサポートされていない場合も次のURLを試す\n            if (err.message.includes('PNG以外の形式はまだサポートされていません')) {\n              continue;\n            }\n            throw err;\n          }\n        }\n        \n        // すべてのURLで失敗\n        sendResponse({ success: false, log: 'メタデータが見つかりません' });\n      } catch (e: any) {\n        sendResponse({ success: false, log: e.message || String(e) });\n      }\n    })();\n    return true; // 非同期レスポンス\n  }\n});\n"],"names":["LSBExtractor","data","__publicField","n","bytes","extractAlphaChannelBits","pixels","width","height","alphaChannel","i","transposedAlphaChannel","y","x","extractRGBChannelBits","columnMajor","rgbBits","index","pixelIndex","packBitsToBytes","bits","packedLength","truncatedBits","packedBytes","byte","j","checkMagicNumber","reader","magicNumbers","maxLength","m","magicBytes","readMagic","magic","format","compressed","decompressGzip","blob","inflateToString","u8","ab","parsePngAlphaChannel","buf","imgBitmap","ctx","dataLength","jsonDataBytes","decompressed","jsonText","jsonData","key","value","parseStableDiffusionForgeMetadata","tabId","metadataText","alphaBits","alphaBytes","alphaReader","alphaResult","dataBytes","rgbBytes","rgbReader","rgbResult","rgbBits2","rgbBytes2","rgbReader2","rgbResult2","parsePngTextChunks","dv","sig","off","latin1","utf8","items","len","type","sep","keyword","text","p","i0","compFlag","compMethod","i1","languageTag","i2","translatedKeyword","textBytes","e","fetchAndParseMetadata","url","res","parsed","sendDebugInfo","label","error","tab","message","sender","sendResponse","_a","imageUrls","metadata","err"],"mappings":"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"}